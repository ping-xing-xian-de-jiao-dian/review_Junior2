作业要电子版

平时10，实验20（6个设计，多做加分），期末70闭卷



## 第一章，编译概论

编译程序：高级语言 -> 低级语言

汇编程序：汇编语言 -> 机器语言

<img src="编译原理.assets/image-20220302092717455.png" alt="image-20220302092717455" style="zoom:60%;" />

源代码 -> 目标代码。预编译、编译、汇编、链接

**编译程序的步骤：**

- 词法分析

  根据词法规则分析和**识别单词**（保留字、标识符、常数和分界符）

- 语法分析

  **识别各种语法成分**（表达式、语句、函数等）并进行语法正确性检查

- 语义分析及中间代码生成

  依据语义规则对识别出的各种语法成份分析其含义，并进行初步翻译，生成中间代码（四元式、三元式、逆波兰表式）

  为什么要生成中间代码：1. 利于代码优化 2. 利于目标代码的移植

- 代码优化

  对中间代码加工变换，得到高质量目标代码

- 目标代码生成

  把中间代码变换成特定机器上的低级语言代码

对源程序从头到尾扫描一次，并做有关的加工处理，生成新的源程序中间形式或目标程序，称之为一**遍**

<img src="编译原理.assets/image-20220302093116328.png" alt="image-20220302093116328" style="zoom:80%;" />



<img src="编译原理.assets/image-20220302094454495.png" alt="image-20220302094454495" style="zoom:80%;" />

翻译包括编译和解释两种形式

编译生成目标文件，解释不生成

> #### 编译程序和解释程序的区别
>
> - 解释程序(解释器),它或者直接解释执行源程序,或者将源程序翻译成某种中间表示形式后再加以执行;
> - 编译程序(编译器),则是将源程序翻译成目标语言程序,然后在计算机上运行目标程序。
> 两种语言处理程序的根本区别是:在编译方式下，机器上运行的是与源程序等价的目标程序，源程序和编译程序都不再参与目标程序的执行过程,而在解释方式下,解释程序和源程序(或某种等价表示)要参与到程序的运行过程中,运行程序的控制权在解释程序。
> 解释器翻译源程序时不生成独立的目标程序,而编译器则将源程序翻译成独立的目标程序。



## 第二章，上下文无关文法和语言

<img src="编译原理.assets/image-20220309081235343.png" alt="image-20220309081235343" style="zoom:50%;" />

### 2.1 文法和语言的表示

- 语言的定义方法
  1. 枚举法：把该语言所有句子列出放在一个集合内
  2. 有限条规则：描述语言的全部句子（有限或无限句子），即文法表示
  3. 装置：检验和识别句子（有限或无限句子），即自动机

### 2.2 文法和语言的定义

- 字母表：元素的非空有穷集合，元素称符号
- 符号串：字母表中符号所组成的任何有穷序列。空符号串（伊普希农）
- 前缀：符号串尾部删去若干（可为0）符号后剩下的就是前缀。若前缀不是本身成为真前缀
- 后缀：定义类似前缀
- 子串：符号串删去一个前缀和一个后缀，不是本身则为真子串
- 方幂：x的n次自身连接，0次幂是空串
- 和：w，w∈A或w∈B
- 积：xy，其中x属于A且y属于B
- 正闭包：A+ = A一次幂∪A二次幂∪...∪An次幂∪...**没有空串！**
- 闭包：A\* = A+∪{空串}
- 语言：闭包里的一个子集



文法（语法）是对语言结构的定义和描述

- 规则（产生式）

  有序对（U，x）记为U→x

  规则的左部：U是符号。规则的右部：x是有穷符号串

  表示U定义为x

- 文法G[Z]

  规则的非空有穷集合

  Z：开始符号（识别符号），至少在一条规则的左部出现

- 字汇表V

  规则左右部中所有符号组成的集合，非终结就是还可以继续推的，终结就是不能继续推了的

  <img src="编译原理.assets/image-20220304105333647.png" alt="image-20220304105333647" style="zoom:60%;" />

- 文法的四元组表示

  G = （V~n~，V~t~，P，Z）P是规则的集合，Z是开始符号

- 文法的BNF（巴斯科范式）表示

  V→x，V→y可以表示为V→x|y



- 直接推导

  <img src="编译原理.assets/image-20220304110253039.png" alt="image-20220304110253039" style="zoom:67%;" />

  推导是顺着的，归约是逆着的

- 推导（长度为n）

  <img src="编译原理.assets/image-20220304110911272.png" alt="image-20220304110911272" style="zoom:67%;" />

- 句型

  凡是由识别符号推导（0步推导也可以）出来的字汇表V上的**终结和非终结符号组成的符号串**叫句型

- 句子

  一步及以上推导，并且最后**属于终结符号**，也是句型

- 语言

  文法G[Z]产生的所有句子的集合

- 等价文法

  不同文法，相同语言。

  规则的集合不同，但是最终由终结符号构成的句子集合是相同的

> 1. 给定文法，可以唯一确定其语言
>
> 2. 给定语言，能确定文法，但是不唯一，是多种等价的文法
>
> 3. <img src="编译原理.assets/image-20220304113657077.png" alt="image-20220304113657077" style="zoom:67%;" />
>
>    把规则能推出来的东西都代进去替换，那么肯定是等价的

- 递归规则

  <img src="编译原理.assets/image-20220304114339379.png" alt="image-20220304114339379" style="zoom:67%;" />

### 2.3 句型的分析

识别输入的符号串是否为某一文法的句型（句子）的过程

最左（右）推导：每次都对最左（右）边的非终结符号进行替换

- 最右推导是规范推导，所得句型叫规范句型

- 规范规约是规范推导的逆过程（最左规约）

- 短语（语法树中非叶片子树的所有叶子结点从左到右连起来）

  <img src="编译原理.assets/image-20220309082749015.png" alt="image-20220309082749015" style="zoom:80%;" />

- 简单短语（语法树中只有两层的子树）

  <img src="编译原理.assets/image-20220309082801670.png" alt="image-20220309082801670" style="zoom:80%;" />

- 句柄

  句型最左边的简单短语为该句型的句柄

- 语法树

  一个句型或句子推导过程的图示法表示

- 文法的二义性（考试5分）

  1. 如果存在两棵及以上不同的语法树（有两个不同的最左或最右推导），则有二义性

  2. 含有二义性的句子，则有二义性
  3. 既含左递归又含右递归，则必是二义性文法

  做题：先找**一个句子**，找到两个最左或最右推导推出这个句子
  
- 二义性消除

  <img src="D:\C_full\编译原理\编译原理.assets\image-20220311114552243.png" alt="image-20220311114552243" style="zoom:80%;" />



### 2.4 文法的实用限制和其他表示法

- 文法中，x在推导过程中被用到过，且最终能推出句子，则x是**有用**的，否则是无用产生式
- 无用产生式（只要用了某规则就一定推不出句子，或者根本用不了这个规则），是规则

**不含有害规则**

<img src="编译原理.assets/image-20220309093418950.png" alt="image-20220309093418950" style="zoom:80%;" />

**空串产生式的消除**

<img src="编译原理.assets/image-20220309093741243.png" alt="image-20220309093741243" style="zoom:80%;" />

<img src="D:\C_full\编译原理\编译原理.assets\image-20220311103135803.png" alt="image-20220311103135803" style="zoom:80%;" />

算法2.4：若L(G)本身不包含空串，消除空串表达式，就是找到所有能推出空串的，并将其推的步骤前移

<img src="D:\C_full\编译原理\编译原理.assets\image-20220311104230604.png" alt="image-20220311104230604" style="zoom:80%;" />

<img src="D:\C_full\编译原理\编译原理.assets\image-20220311104620128.png" alt="image-20220311104620128" style="zoom:80%;" />



### 2.5 文法和语言的Chomsky分类

- 0型文法

  α→β，α∈V+，β∈V*

  V+是正闭包，V*是闭包

  递归可枚举语言，图灵机

- 1型文法

  α~1~Aα~2~→α~1~βα~2~		α~1~，α~2~∈V*		A∈V~n~，β∈V+
  
  上下文有关文法，线性限界自动机
  
  aUb→aABBaab
  
- **2型文法**
  
  A→β		A∈V~n~，β∈V+
  
  上下文无关文法
  
  <img src="D:\C_full\编译原理\编译原理.assets\image-20220311111932477.png" alt="image-20220311111932477" style="zoom:80%;" />
  
- **3型文法**

  A→aB或A→a		A、B∈V~n~，a∈V~t~

  右线形正则文法

  A→Ba或A→a		A、B∈V~n~，a∈V~t~

  左线形正则文法

  有限状态语言，有限自动机

<img src="D:\C_full\编译原理\编译原理.assets\image-20220311112348123.png" alt="image-20220311112348123" style="zoom:80%;" />



## 第三章、词法分析

### 3.1 设计扫描器应考虑的几个问题

任务：从左至右逐个字符对源程序扫描，产生

- 设计与实现扫描器需重点解决
  1. 结构：3型文法
  2. 识别：状态转换图、有限自动机、正则表达式



### 3.2 正则文法和状态转换图

右线性文法

<img src="D:\C_full\编译原理\编译原理.assets\image-20220316084649532.png" alt="image-20220316084649532" style="zoom:80%;" />

左线性文法

<img src="D:\C_full\编译原理\编译原理.assets\image-20220316091940711.png" alt="image-20220316091940711" style="zoom:80%;" />



### 3.3 有限自动机

**确定有限自动机**

<img src="D:\C_full\编译原理\编译原理.assets\image-20220318101720697.png" alt="image-20220318101720697" style="zoom:80%;" />

正则文法一定和某个DFA等价

**非确定有限自动机**

<img src="D:\C_full\编译原理\编译原理.assets\image-20220318103304304.png" alt="image-20220318103304304" style="zoom:80%;" />

<img src="D:\C_full\编译原理\编译原理.assets\image-20220318104336151.png" alt="image-20220318104336151" style="zoom:80%;" />

读空串不动作的，最笨的方法 ↓

<img src="D:\C_full\编译原理\编译原理.assets\image-20220318105523994.png" alt="image-20220318105523994" style="zoom:80%;" />

删去多余的，就只剩q034了



读空串有动作的

<img src="D:\C_full\编译原理\编译原理.assets\image-20220318111442185.png" alt="image-20220318111442185" style="zoom:80%;" />

<img src="D:\C_full\编译原理\编译原理.assets\image-20220318112105762.png" alt="image-20220318112105762" style="zoom:80%;" />

<img src="D:\C_full\编译原理\编译原理.assets\image-20220318112501271.png" alt="image-20220318112501271" style="zoom:80%;" />

所有的步骤都是求它的**空串闭包**

<img src="D:\C_full\编译原理\编译原理.assets\image-20220318113202480.png" alt="image-20220318113202480" style="zoom:80%;" />

1. 求起始点的空串闭包
2. 空串闭包和a、b、c等作用，得到新的点，再求空串闭包
3. 直到求不出新的来

第二种解法 ↓

<img src="D:\C_full\编译原理\编译原理.assets\image-20220318113750914.png" alt="image-20220318113750914" style="zoom:80%;" />

![image-20220318115437878](D:\C_full\编译原理\编译原理.assets\image-20220318115437878.png)

上标1是终止，2是非终止

下标是指和什么字母作用

